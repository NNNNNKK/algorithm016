错误笔记:
1、调用方式
  __stdcall调用约定：函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈。
  __cdecl是C和C++程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。
函数采用从右到左的压栈方式。注意：对于可变参数的成员函数，始终使用__cdecl的转换方式。
  __fastcall调用约定：它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，
剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈）。
   thiscall仅仅应用于"C++"成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。
   nakedcall采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。
naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同使用。
2、C++中能作为函数重载判断依据的有：参数类型、const和参数个数。切记返回值类型不能作为函数重载的依据。
3、堆和栈都可以动态分配内存，但是堆不可以进行静态分配，堆的申请都是在执行过程中进行的。
4、^为异或运算符。
5、结构体中字节对齐有两条规则：①数据成员自对齐，即数据成员起始地址为数据类型长度的整数倍，如该题int型b只能从0，2，4...等地址处开始放；
②结构体总长度是结构体中有效对齐值的整数倍，有效对齐值，如该题没明确指出，则为最长数据成员(int b)长度的整数倍；
6、①空白符，包括空格、制表符、换行符，只是用来占位，没有实际内容。对于编译器来说，有点会被忽略（一般是在（）钟）；
有的不会被忽略（一般是在“”中）②标识符在C语言 中一般是8字符，在C++中一般是32字符，在Java中则没有限制。
7、文件打开方式：ios:in 为读文件而打开文件   ios:out 为写文件而打开文件，会删除原文件内容，相当于turnc|out
ios:ate 初始文件位置：文件尾   ios:app 追加方式写文件  ios:trunc 如果文件存在先删除，在创建   ios:binary 二进制方式
8、STL库中，map和multimap底层都是红黑树实现的，两者的不同在于multimap允许重复的可以，而map中不行。
红黑树的查找复杂度为O(log(n))；unodered_map/_set底层是哈希表实现的，查找复杂度为O(1)
